local WORLD = require "scenes.game.model.world"
local HASHES = require "libs.hashes"
local GOOEY = require "gooey.themes.dirtylarry.dirtylarry"
local INPUT = require "libs.input_receiver"
local LUME = require "libs.lume"
local ProgressBar = require "libs.progress_bar"
---@class SelfGui1
---@param self SelfGui1

---@param self SelfGui1
local function update_disk_space(self)
    local rotation = 0
    for i = 1, 4 do
        local space = self.disk_space[i]
        local ui = self.ui[i]
        gui.set_text(ui.lbl,space)
        gui.set_rotation(ui.pie, vmath.vector3(0, 0, rotation))
        gui.set_fill_angle(ui.pie, 360 * space)
        rotation = rotation + 360 * space
    end
end
---@param self SelfGui1
local function find_clicked_pie(self, action)
    for i = 2, 4 do
        if gui.pick_node(self.ui[i].lbl, action.x, action.y) then
            print(i)
            return i
        end
    end
end

---@param self SelfGui1
local function update_station_hp(self)
    self.station_hp:set_progress(WORLD.station_hp)
end

---@param direction number 1 right -1 left
local function change_size(self, direction, add)
    if not self.selected_node then
        return
    end
    if self.selected_node == 1 then
        return
    end
    if self.selected_node == 2 and direction == -1 then
        return
    end
    if self.selected_node == 4 and direction == 1 then
        return
    end
    local next_node = self.selected_node + direction

    local value = self.disk_space[self.selected_node] + add
    local next_value = self.disk_space[next_node] - add
    if value < 0.0001 or value > 0.99999 or next_value < 0.0001 or next_value > 0.9999 then
        return
    end
    self.disk_space[self.selected_node] = value
    self.disk_space[next_node] = next_value
    update_disk_space(self)
end
local function change_pie_value(self, node, value)
    value = math.floor(value * 1000)/1000
    if node == 1 then
        return
    end
    if node == 4 then
        return
    end
    local next_node = node + 1

    local delta =  math.floor((value - self.disk_space[node])*100)/100
    if self.disk_space[node] + delta < 0.00001 then
        return
    end
    if self.disk_space[next_node] - delta < 0.00001 then
        return
    end
    self.disk_space[node] = LUME.clamp(self.disk_space[node] + delta,0.01,1)
    self.disk_space[next_node] = LUME.clamp(self.disk_space[next_node] - delta,0.01,1)
   -- self.disk_space[node] = math.floor((self.disk_space[node])*100)/100
  --  self.disk_space[next_node] = math.floor((self.disk_space[next_node])*100)/100
    update_disk_space(self)
end
---@param self SelfGui1
local function update_hero_cells(self)
    for i = 1, 3 do
        local hero_cell = self.hero_cells[i]
        local hero = WORLD.heroes[i]
        --gui.set_text(hero_cell.lbl_h ,"happy:" .. hero.happy)
        --gui.set_text(hero_cell.lbl_p ,"productivity" .. hero.productivity)
        hero_cell.progress_h:set_progress(hero.happy)
        hero_cell.progress_p:set_progress(hero.productivity)
    end
end

---@param self SelfGui1
local function on_input_btns(self, action_id, action)
    local group = GOOEY.group("group1", function()
        GOOEY.button("btn_ok", action_id, action, function(button)
            WORLD:act({ self.disk_space[2], self.disk_space[3], self.disk_space[4] })
            update_hero_cells(self)
        end)
    end)
    return group.consumed
end

function init(self)
    INPUT.acquire()
    WORLD:reset()
    self.ui = {
        { pie = gui.get_node("pie0"), lbl = gui.get_node("text0") },
        { pie = gui.get_node("pie1"), lbl = gui.get_node("text1") },
        { pie = gui.get_node("pie2"), lbl = gui.get_node("text2") },
        { pie = gui.get_node("pie3"), lbl = gui.get_node("text3") },
    }
    self.hero_cells = {
        { lbl_h = gui.get_node("hero_1/lbl_happy"), lbl_p = gui.get_node("hero_1/lbl_productivity"),
          progress_h = ProgressBar("hero_1/progress_happy"), progress_p = ProgressBar("hero_1/progress_productivity") },
        { lbl_h = gui.get_node("hero_2/lbl_happy"), lbl_p = gui.get_node("hero_2/lbl_productivity"),
          progress_h = ProgressBar("hero_2/progress_happy"), progress_p = ProgressBar("hero_2/progress_productivity") },
        { lbl_h = gui.get_node("hero_3/lbl_happy"), lbl_p = gui.get_node("hero_3/lbl_productivity"),
          progress_h = ProgressBar("hero_3/progress_happy"), progress_p = ProgressBar("hero_3/progress_productivity") },
    }
    self.drag_node_1 = gui.get_node("drag_node_1")
    self.drag_node_2 = gui.get_node("drag_node_2")
    self.station_hp = ProgressBar("progress_station")
    self.disk_space = { 0.4, 0.1, 0.25, 0.25 }
    update_disk_space(self)
    update_hero_cells(self)
    update_station_hp(self)
    self.pie_center = gui.get_position(gui.get_node("disk_sectors"))
end

function final(self)
    INPUT.release()
    WORLD:reset()
end

function update(self, dt)
    -- Add update code here
    -- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
    -- Add message-handling code here
    -- Remove this function if not needed
end

function on_input(self, action_id, action)
    if on_input_btns(self, action_id, action) then
        return
    end
    if action_id == HASHES.INPUT_TOUCH then
        if action.pressed then
            if gui.pick_node(self.drag_node_1, action.x, action.y) then
                self.selected_drag = 2
                self.drag_node = 2
                self.selected_node = 2
                self.drag_start_angle = gui.get_fill_angle(self.ui[self.drag_node].pie)
                self.selected_drag_point = vmath.vector3(action.x, action.y, 0) - self.pie_center
            elseif gui.pick_node(self.drag_node_2, action.x, action.y) then
                self.selected_drag = 3
                self.drag_node = 3
                self.selected_node = 3
                self.drag_start_angle = gui.get_fill_angle(self.ui[self.drag_node].pie)
                self.selected_drag_point = vmath.vector3(action.x, action.y, 0) - self.pie_center
            end
            --[[if self.selected_node then gui.set_size(self.ui[self.selected_node].pie, vmath.vector3(400,400,0)) end
            self.selected_node = find_clicked_pie(self, action)
            if self.selected_node then gui.set_size(self.ui[self.selected_node].pie, vmath.vector3(500,500,0)) end--]]
        elseif action.released then
            self.on_touched_disk = false
            self.selected_drag = nil
            self.drag_node = nil
            self.selected_drag_point = nil
        end
        if self.selected_drag then
            local v1 = vmath.vector3(action.x, action.y, 0) - self.pie_center
            local a = self.selected_drag_point
            local angle = math.atan2(a.x * v1.y - v1.x * a.y, a.x * v1.x + a.y * v1.y)
            -- print("*****")
            -- print(self.drag_start_angle)
            -- print(math.deg(angle))
            angle = self.drag_start_angle + math.deg(angle)
            local value = angle / 360 * 1
            change_pie_value(self, self.selected_node, value)
        end
    end

end

function on_reload(self)
    -- Add input-handling code here
    -- Remove this function if not needed
end
